<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwriting Recognition</title>
    <style>body {
  background-color: #f0f0f0;
  flex-direction: column;
  align-items: center;
  margin: 0;
  padding: 20px;
  font-family: Arial, sans-serif;
  display: flex;
}

.container {
  background-color: #fff;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 0 10px #0000001a;
}

canvas {
  border: 2px solid #333;
  border-radius: 5px;
  margin-bottom: 10px;
}

.controls {
  gap: 10px;
  margin-bottom: 20px;
  display: flex;
}

button {
  cursor: pointer;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  font-size: 16px;
  transition: background-color .3s;
}

.clear {
  color: #fff;
  background-color: #f44;
}

.predict {
  color: #fff;
  background-color: #4caf50;
}

button:hover {
  opacity: .9;
}

.result {
  text-align: center;
  margin-top: 20px;
  font-size: 24px;
}
</style>
</head>
<body>
    <div class="container">
        <h1>Handwriting Recognition</h1>
        <canvas id="drawingCanvas" width="280" height="280"></canvas>
        <div class="controls">
            <button class="clear" onclick="clearCanvas()">Clear</button>
            <button class="predict" onclick="predict()">Predict</button>
        </div>
        <div class="result" id="result">Draw a digit (0-9)</div>
    </div>
    <script>const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
let isDrawing = false;
let lastX = 0;
let lastY = 0;
// Set up canvas
ctx.strokeStyle = 'black';
ctx.lineWidth = 15;
ctx.lineCap = 'round';
// Set white background
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Drawing event listeners
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);
function startDrawing(e) {
    isDrawing = true;
    [lastX, lastY] = [
        e.offsetX,
        e.offsetY
    ];
}
function draw(e) {
    if (!isDrawing) return;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    [lastX, lastY] = [
        e.offsetX,
        e.offsetY
    ];
}
function stopDrawing() {
    isDrawing = false;
}
function clearCanvas() {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    document.getElementById('result').textContent = 'Draw a digit (0-9)';
}
function resizeImageData(imageData, width, height) {
    // Create a temporary canvas to resize the image
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    // Draw the original image data onto the temporary canvas
    const originalCanvas = document.createElement('canvas');
    originalCanvas.width = imageData.width;
    originalCanvas.height = imageData.height;
    const originalCtx = originalCanvas.getContext('2d');
    originalCtx.putImageData(imageData, 0, 0);
    // Use built-in canvas scaling to resize
    tempCtx.drawImage(originalCanvas, 0, 0, width, height);
    // Get the resized image data
    return tempCtx.getImageData(0, 0, width, height);
}
async function predict() {
    // Get image data from the drawing canvas (280x280)
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // Resize to 28x28
    const resizedData = resizeImageData(imageData, 28, 28);
    const data = resizedData.data;
    // Convert to grayscale array (0-1)
    const pixels = [];
    for(let i = 0; i < data.length; i += 4){
        // Convert RGBA to grayscale using luminance formula
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        // Calculate grayscale and invert (1 - value) since MNIST uses white digits on black background
        const gray = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        pixels.push(gray);
    }
    console.log('Sending pixels:', pixels.length, 'values');
    console.log('Sample values:', pixels.slice(0, 10));
    try {
        const response = await fetch('http://localhost:3000/predict', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                pixels
            })
        });
        const result = await response.json();
        console.log('Received result:', result);
        if (result.error) document.getElementById('result').textContent = `Error: ${result.error}`;
        else if (result.prediction !== undefined) document.getElementById('result').textContent = `Predicted digit: ${result.prediction}`;
        else document.getElementById('result').textContent = 'Error: Invalid response from server';
    } catch (error) {
        console.error('Error:', error);
        document.getElementById('result').textContent = 'Error: Could not get prediction';
    }
}

</script>


<script src="/frontend.3464ddca.js"></script></body></html>